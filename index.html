import pysftp
from concurrent.futures import ThreadPoolExecutor

def download_sftp_files_parallel(sftp_host, sftp_username, sftp_password, file_list, local_directory, max_workers=5):
    """Downloads files from an SFTP server in parallel.

    Args:
        sftp_host (str): The hostname or IP address of the SFTP server.
        sftp_username (str): The username for the SFTP server.
        sftp_password (str): The password for the SFTP server.
        file_list (list[str]): A list of file paths on the SFTP server.
        local_directory (str): The local directory where downloaded files will be saved.
        max_workers (int, optional): The maximum number of files to download concurrently.
            Defaults to 5.

    Raises:
        Exception: If an error occurs during downloading.
    """

    def download_file(remote_file, local_file):
        try:
            with sftp.Connection(
                host=sftp_host, username=sftp_username, password=sftp_password
            ) as sftp:
                sftp.get(remote_file, local_file)
                print(f"Downloaded: {remote_file}")
        except Exception as e:
            print(f"Error downloading {remote_file}: {e}")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        for remote_file in file_list:
            # Generate unique local filenames with UUIDs to avoid overwriting
            local_filename = os.path.join(
                local_directory, os.path.basename(remote_file) + uuid4().hex[:10]
            )
            executor.submit(download_file, remote_file, local_filename)

if __name__ == "__main__":
    # Example usage:
    sftp_host = "your_sftp_host"
    sftp_username = "your_sftp_username"
    sftp_password = "your_sftp_password"
    file_list = ["/remote/path/file1.txt", "/remote/path/folder/file2.zip"]
    local_directory = "/local/download/directory"

    download_sftp_files_parallel(
        sftp_host, sftp_username, sftp_password, file_list, local_directory
    )

~

